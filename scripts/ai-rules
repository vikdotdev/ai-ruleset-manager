#!/bin/sh
set -e

# AI Ruleset Manager - Template Repository CLI
# POSIX-compliant script for building rule documentation from manifests

# Resolve symlink to get actual script location
SCRIPT_PATH="$0"
if [ -L "$SCRIPT_PATH" ]; then
    # Follow symlink (POSIX-compatible way)
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH" || echo "$SCRIPT_PATH")"
fi
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
PROJECT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
RULES_DIR="${LLM_RULES_DIR:-$PROJECT_DIR/rules}"
VERSION="1.0.0"

# Print usage
usage() {
    cat <<EOF
ai-rules - Build and manage AI instruction rulesets

Usage:
    ai-rules <command> [options]

Commands:
    build       Build documentation from a manifest
    install     Install ai-rules to your system
    build-link  Build and symlink output to a location
    validate    Validate a database manifest
    new         Create a new database
    help        Show this help message

Run 'ai-rules <command> --help' for more information on a command.

Version: $VERSION
EOF
}

# Build command usage
usage_build() {
    cat <<EOF
Usage: ai-rules build --manifest <path> [--out <file>]

Build documentation from a manifest file.

Options:
    --manifest <path>   Path to manifest.ini file (required)
    --out <file>        Output file path (default: build/<database>.md)

Example:
    ai-rules build --manifest rules/myproject/manifest
    ai-rules build --manifest rules/myproject/manifest --out docs.md
EOF
}

# Install command usage
usage_install() {
    cat <<EOF
Usage: ai-rules install [--prefix <path>] [--bin-name <name>]

Install ai-rules to your system.

Options:
    --prefix <path>     Installation directory (will prompt if not provided)
    --bin-name <name>   Custom binary name (default: ai-rules)

Example:
    ai-rules install --prefix ~/bin
    ai-rules install --prefix /usr/local/bin
    ai-rules install --bin-name my-ai-tool
EOF
}

# Build-link command usage
usage_build_link() {
    cat <<EOF
Usage: ai-rules build-link --manifest <path> --out <file>

Build documentation and create a symlink at the specified location.

Options:
    --manifest <path>   Path to manifest file (required)
    --out <file>        Symlink destination path (required)

Example:
    ai-rules build-link --manifest rules/myproject/manifest --out ~/docs/project.md
EOF
}

# New command usage
usage_new() {
    cat <<EOF
Usage: ai-rules new --database <name>

Create a new database with template structure.

Options:
    --database <name>   Name of the new database (required)

Example:
    ai-rules new --database myproject
    ai-rules new --database react-frontend
EOF
}

# Validate command usage
usage_validate() {
    cat <<EOF
Usage: ai-rules validate --manifest <path>

Validate a manifest file and check for missing rule files.

Options:
    --manifest <path>   Path to manifest.ini file (required)

Example:
    ai-rules validate --manifest rules/myproject/manifest
EOF
}

# Function to normalize heading levels in markdown
normalize_headings() {
    local file="$1"
    local target_level="${2:-3}"  # Default to level 3 if not specified
    local min_level=6
    local in_code_block=0

    # First pass: find minimum heading level outside code blocks
    while IFS= read -r line; do
        # Check for code block boundaries
        case "$line" in
            '```'*|'~~~'*)
                if [ $in_code_block -eq 0 ]; then
                    in_code_block=1
                else
                    in_code_block=0
                fi
                ;;
            *)
                # Only process if not in code block
                if [ $in_code_block -eq 0 ]; then
                    # Check if line is a heading
                    case "$line" in
                        '#'*)
                            # Count leading hashes
                            heading_level=$(echo "$line" | sed 's/^\(#*\).*/\1/' | wc -c)
                            heading_level=$((heading_level - 1))  # Adjust for newline
                            if [ $heading_level -gt 0 ] && [ $heading_level -lt $min_level ]; then
                                min_level=$heading_level
                            fi
                            ;;
                    esac
                fi
                ;;
        esac
    done < "$file"

    # Calculate shift needed to reach target level
    shift=$((target_level - min_level))

    # Second pass: apply shift to headings
    in_code_block=0
    while IFS= read -r line; do
        # Check for code block boundaries
        case "$line" in
            '```'*|'~~~'*)
                if [ $in_code_block -eq 0 ]; then
                    in_code_block=1
                else
                    in_code_block=0
                fi
                printf '%s\n' "$line"
                ;;
            *)
                if [ $in_code_block -eq 1 ]; then
                    # In code block, output as-is
                    printf '%s\n' "$line"
                else
                    # Check if line is a heading
                    case "$line" in
                        '#'*)
                            # Extract heading level and content
                            hashes=$(echo "$line" | sed 's/^\(#*\).*/\1/')
                            content=$(echo "$line" | sed 's/^#* *//')
                            heading_level=$(echo "$hashes" | wc -c)
                            heading_level=$((heading_level - 1))  # Adjust for newline

                            # Apply shift
                            new_level=$((heading_level + shift))

                            # Clamp to maximum H6
                            if [ $new_level -gt 6 ]; then
                                new_level=6
                            fi

                            # Output adjusted heading
                            i=0
                            while [ $i -lt $new_level ]; do
                                printf '#'
                                i=$((i + 1))
                            done
                            printf ' %s\n' "$content"
                            ;;
                        *)
                            # Not a heading, output as-is
                            printf '%s\n' "$line"
                            ;;
                    esac
                fi
                ;;
        esac
    done < "$file"

    # Handle the last line if it doesn't end with newline
    if [ -n "$line" ]; then
        case "$line" in
            '```'*|'~~~'*)
                if [ $in_code_block -eq 0 ]; then
                    in_code_block=1
                else
                    in_code_block=0
                fi
                printf '%s\n' "$line"
                ;;
            *)
                if [ $in_code_block -eq 1 ]; then
                    printf '%s\n' "$line"
                else
                    case "$line" in
                        '#'*)
                            hashes=$(echo "$line" | sed 's/^\(#*\).*/\1/')
                            content=$(echo "$line" | sed 's/^#* *//')
                            heading_level=$(echo "$hashes" | wc -c)
                            heading_level=$((heading_level - 1))
                            new_level=$((heading_level + shift))
                            if [ $new_level -gt 6 ]; then
                                new_level=6
                            fi
                            i=0
                            while [ $i -lt $new_level ]; do
                                printf '#'
                                i=$((i + 1))
                            done
                            printf ' %s\n' "$content"
                            ;;
                        *)
                            printf '%s\n' "$line"
                            ;;
                    esac
                fi
                ;;
        esac
    fi
}

# Process a rule file
process_rule() {
    local rule_path="$1"
    local manifest_dir="$2"
    local target_level="${3:-1}"  # Default to level 1 if not specified
    local full_path=""

    # Add .md extension if not present (for new pipe format)
    case "$rule_path" in
        *.md)
            # Already has extension
            ;;
        *)
            # Add .md extension
            rule_path="$rule_path.md"
            ;;
    esac

    # Handle cross-database includes (e.g., other-db/rule)
    case "$rule_path" in
        */*)
            # Cross-database reference: database/rule -> RULES_DIR/database/rules/rule.md
            db_name="${rule_path%%/*}"
            rule_name="${rule_path#*/}"
            full_path="$RULES_DIR/$db_name/rules/$rule_name"
            ;;
        *)
            # Local to current database
            full_path="$manifest_dir/rules/$rule_path"
            ;;
    esac

    if [ ! -f "$full_path" ]; then
        echo "Warning: Rule file not found: $full_path" >&2
        return 1
    fi

    # Generate and output rule title heading
    rule_title=$(generate_rule_title "$(basename "$rule_path")")

    # Output the rule title at the target level
    i=0
    while [ $i -lt $target_level ]; do
        printf '#'
        i=$((i + 1))
    done
    printf ' %s\n' "$rule_title"

    # Normalize and output the rule content with target level + 1 (nested under title)
    # Create temporary file with normalized content
    content_level=$((target_level + 1))
    temp_content=$(mktemp)
    normalize_headings "$full_path" "$content_level" > "$temp_content"

    # Trim leading blank lines
    sed -i '/./,$!d' "$temp_content"

    # Trim trailing blank lines
    sed -i -e :a -e '/^\s*$/{$d;N;ba' -e '}' "$temp_content"

    # Output the trimmed content
    cat "$temp_content"
    rm -f "$temp_content"

    # Add single newline between rules
    printf '\n'
}

# Generate a clean title from a rule filename
generate_rule_title() {
    local rule_name="$1"
    local base_name=""

    # Remove .md extension if present
    case "$rule_name" in
        *.md)
            base_name="${rule_name%.md}"
            ;;
        *)
            base_name="$rule_name"
            ;;
    esac

    # Format as "Rule: <name>"
    echo "Rule: $base_name"
}

# Parse a pipe-based line and extract level and rule name
# Returns: "level rule_name" or empty string if invalid
parse_pipe_line() {
    local line="$1"
    local pipe_count=0
    local rule_name=""

    # Count leading pipes
    while [ "${line#|}" != "$line" ]; do
        pipe_count=$((pipe_count + 1))
        line="${line#|}"
    done

    # Must have at least one pipe
    if [ $pipe_count -eq 0 ]; then
        return 1
    fi

    # Extract rule name after pipes and whitespace
    rule_name=$(echo "$line" | sed 's/^[[:space:]]*//')

    # Must have a rule name
    if [ -z "$rule_name" ]; then
        return 1
    fi

    # Validate level (1-6 for markdown heading limits)
    if [ $pipe_count -gt 6 ]; then
        echo "Error: Too many nesting levels ($pipe_count). Maximum is 6." >&2
        return 1
    fi

    echo "$pipe_count $rule_name"
    return 0
}

# Helper function to validate a manifest silently (returns 0 if valid, 1 if invalid)
validate_manifest() {
    local manifest_path="$1"
    local manifest_dir=$(dirname "$manifest_path")

    # Validation counters
    local total_rules=0
    local missing_rules=0

    # Parse manifest and validate each rule
    local prev_level=0
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip empty lines
        if [ -z "$line" ]; then
            continue
        fi

        # Skip comments
        case "$line" in
            '#'*)
                continue
                ;;
            *)
                # Try to parse as pipe-based line
                if parsed=$(parse_pipe_line "$line"); then
                    # Extract level and rule name
                    level=$(echo "$parsed" | cut -d' ' -f1)
                    rule_name=$(echo "$parsed" | cut -d' ' -f2-)

                    # Validate nesting (can't jump levels) - auto-correct for validation
                    if [ $level -gt $((prev_level + 1)) ]; then
                        corrected_level=$((prev_level + 1))
                        level=$corrected_level
                    fi

                    total_rules=$((total_rules + 1))

                    # Add .md extension if not present
                    case "$rule_name" in
                        *.md)
                            # Already has extension
                            ;;
                        *)
                            # Add .md extension
                            rule_name="$rule_name.md"
                            ;;
                    esac

                    # Check if rule file exists
                    case "$rule_name" in
                        */*)
                            # Cross-database reference: database/rule -> RULES_DIR/database/rules/rule.md
                            db_name="${rule_name%%/*}"
                            rule_file="${rule_name#*/}"
                            # Remove .md if present, will be re-added
                            rule_file="${rule_file%.md}.md"
                            rule_path="$RULES_DIR/$db_name/rules/$rule_file"
                            ;;
                        *)
                            # Local rule
                            rule_path="$manifest_dir/rules/$rule_name"
                            ;;
                    esac

                    if [ ! -f "$rule_path" ]; then
                        echo "Error: Rule file not found: $rule_path" >&2
                        echo "Referenced in manifest: $manifest_path" >&2
                        missing_rules=$((missing_rules + 1))
                    fi
                    prev_level=$level
                else
                    # Try legacy format (lines without pipes)
                    trimmed=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                    if [ -n "$trimmed" ]; then
                        total_rules=$((total_rules + 1))

                        # Check if rule file exists (legacy format)
                        case "$trimmed" in
                            */*)
                                # Cross-database reference
                                rule_path="$RULES_DIR/$trimmed"
                                ;;
                            *)
                                # Local rule
                                rule_path="$manifest_dir/rules/$trimmed"
                                ;;
                        esac

                        if [ ! -f "$rule_path" ]; then
                            echo "Error: Rule file not found: $rule_path" >&2
                            echo "Referenced in manifest: $manifest_path" >&2
                            missing_rules=$((missing_rules + 1))
                        fi
                    fi
                fi
                ;;
        esac
    done < "$manifest_path"

    # Return exit code based on validation result
    if [ $missing_rules -eq 0 ]; then
        return 0
    else
        return 1
    fi
}

# Build command
cmd_build() {
    local manifest=""
    local output=""

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --manifest)
                manifest="$2"
                shift 2
                ;;
            --out)
                output="$2"
                shift 2
                ;;
            --help|-h)
                usage_build
                exit 0
                ;;
            *)
                echo "Error: Unknown option $1" >&2
                usage_build
                exit 1
                ;;
        esac
    done

    # Validate manifest argument
    if [ -z "$manifest" ]; then
        echo "Error: --manifest is required" >&2
        usage_build
        exit 1
    fi

    # Check if manifest exists
    if [ ! -f "$manifest" ]; then
        echo "Error: Manifest file not found: $manifest" >&2
        exit 1
    fi

    # Validate manifest before building
    if ! validate_manifest "$manifest"; then
        echo "Error: Manifest validation failed. Build aborted." >&2
        exit 1
    fi

    # Get manifest directory
    manifest_dir=$(dirname "$manifest")

    # Determine output file if not specified
    local using_default_build_dir=false
    if [ -z "$output" ]; then
        # Extract database name from manifest path
        database=$(basename "$manifest_dir")
        output="build/${database}.md"
        using_default_build_dir=true
    fi

    # Check if output directory exists, auto-create if using default build/ directory
    output_dir=$(dirname "$output")
    if [ ! -d "$output_dir" ]; then
        if [ "$using_default_build_dir" = true ]; then
            mkdir -p "$output_dir"
        else
            echo "Error: Output directory does not exist: $output_dir" >&2
            echo "Create it first with: mkdir -p $output_dir" >&2
            exit 1
        fi
    fi

    # Build to a temporary file first, then move to output
    tmp_output="${output}.tmp.$$"

    # Parse manifest and build output
    prev_level=0

    # Process manifest line by line
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip empty lines
        if [ -z "$line" ]; then
            continue
        fi

        # Skip comments
        case "$line" in
            '#'*)
                continue
                ;;
            *)
                # Try to parse as pipe-based line
                if parsed=$(parse_pipe_line "$line"); then
                    # Extract level and rule name
                    level=$(echo "$parsed" | cut -d' ' -f1)
                    rule_name=$(echo "$parsed" | cut -d' ' -f2-)

                    # Validate nesting - can only increase by 1, but can decrease to any level
                    if [ $level -gt $((prev_level + 1)) ]; then
                        corrected_level=$((prev_level + 1))
                        echo "Warning: Invalid nesting in manifest. Level $level follows level $prev_level." >&2
                        echo "Line: $line" >&2
                        echo "Auto-correcting to level $corrected_level" >&2
                        level=$corrected_level
                    fi

                    # Process the rule with the corrected level
                    process_rule "$rule_name" "$manifest_dir" "$level" >> "$tmp_output"

                    # Update prev_level for next iteration
                    # When going back to a lower level, that becomes the new comparison point
                    prev_level=$level
                else
                    # Try legacy format (lines without pipes)
                    trimmed=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                    if [ -n "$trimmed" ]; then
                        # Process as legacy rule file (default level 1)
                        process_rule "$trimmed" "$manifest_dir" 1 >> "$tmp_output"
                    fi
                fi
                ;;
        esac
    done < "$manifest"

    # Trim trailing whitespace and move to final output
    sed -e :a -e '/^\s*$/{$d;N;ba' -e '}' "$tmp_output" > "$output"
    rm -f "$tmp_output"

    echo "Successfully built $output from $manifest"
}

# Install command
cmd_install() {
    local prefix=""
    local bin_name="ai-rules"

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --prefix)
                prefix="$2"
                shift 2
                ;;
            --bin-name)
                bin_name="$2"
                shift 2
                ;;
            --help|-h)
                usage_install
                exit 0
                ;;
            *)
                echo "Error: Unknown option $1" >&2
                usage_install
                exit 1
                ;;
        esac
    done

    # Show current PATH to help user decide
    if [ -z "$prefix" ]; then
        echo "Available directories in your PATH:"

        # Convert PATH to array and display with numbers
        path_dirs=""
        counter=1
        IFS=':'
        for dir in $PATH; do
            if [ -d "$dir" ]; then
                echo "  $counter. $dir"
                if [ -z "$path_dirs" ]; then
                    path_dirs="$dir"
                else
                    path_dirs="$path_dirs:$dir"
                fi
                counter=$((counter + 1))
            fi
        done
        IFS=' '

        echo "  c. Custom directory"
        echo ""
        printf "Select directory by number or 'c' for custom (default: ~/bin): "
        read -r choice

        if [ -z "$choice" ]; then
            prefix="$HOME/bin"
        elif [ "$choice" = "c" ] || [ "$choice" = "C" ]; then
            printf "Enter custom directory: "
            read -r prefix
            if [ -z "$prefix" ]; then
                prefix="$HOME/bin"
            fi
        else
            # Parse the selected number
            selected_counter=1
            IFS=':'
            for dir in $path_dirs; do
                if [ "$selected_counter" = "$choice" ]; then
                    prefix="$dir"
                    break
                fi
                selected_counter=$((selected_counter + 1))
            done
            IFS=' '

            # If invalid number, default to ~/bin
            if [ -z "$prefix" ] || [ "$prefix" = "$choice" ]; then
                echo "Invalid selection. Using default: ~/bin"
                prefix="$HOME/bin"
            fi
        fi
    fi

    # Expand tilde if present
    prefix=$(eval echo "$prefix")

    # Remove trailing slash to normalize path
    prefix="${prefix%/}"

    # Check if directory exists
    if [ ! -d "$prefix" ]; then
        echo "Error: Directory '$prefix' does not exist"
        echo "Create it first or choose an existing directory"
        exit 1
    fi

    # Create symlink
    target="$prefix/$bin_name"
    if [ -e "$target" ]; then
        echo "Warning: $target already exists. Overwrite? (y/N)"
        read -r answer
        case "$answer" in
            y|Y) rm -f "$target" ;;
            *) echo "Installation cancelled"; exit 1 ;;
        esac
    fi

    ln -s "$SCRIPT_DIR/ai-rules" "$target"
    echo "Successfully installed $bin_name to $target"

    # Check if prefix is in PATH
    case ":$PATH:" in
        *":$prefix:"*)
            echo "✓ $prefix is in your PATH - you can now use '$bin_name' from anywhere"
            ;;
        *)
            echo "⚠ $prefix is not in your PATH"
            echo "To use '$bin_name' from anywhere, add this to your shell config:"
            echo "  export PATH=\"\$PATH:$prefix\""
            ;;
    esac
}

# Build-link command
cmd_build_link() {
    local manifest=""
    local output=""

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --manifest)
                manifest="$2"
                shift 2
                ;;
            --out)
                output="$2"
                shift 2
                ;;
            --help|-h)
                usage_build_link
                exit 0
                ;;
            *)
                echo "Error: Unknown option $1" >&2
                usage_build_link
                exit 1
                ;;
        esac
    done

    # Validate arguments
    if [ -z "$manifest" ]; then
        echo "Error: --manifest is required" >&2
        usage_build_link
        exit 1
    fi

    if [ -z "$output" ]; then
        echo "Error: --out is required" >&2
        usage_build_link
        exit 1
    fi

    # Extract database name from manifest path
    manifest_dir=$(dirname "$manifest")
    database=$(basename "$manifest_dir")
    build_file="build/${database}.md"

    # Build the documentation first
    cmd_build --manifest "$manifest" --out "$build_file"

    # Check if output directory exists
    output_dir=$(dirname "$output")
    if [ ! -d "$output_dir" ]; then
        echo "Error: Output directory does not exist: $output_dir" >&2
        echo "Create it first with: mkdir -p $output_dir" >&2
        exit 1
    fi

    # Create or update symlink
    if [ -e "$output" ]; then
        rm -f "$output"
    fi

    # Get absolute path to build file
    abs_build_file="$(cd "$(dirname "$build_file")" && pwd)/$(basename "$build_file")"

    ln -s "$abs_build_file" "$output"
    echo "Successfully deployed to $output"
}

# New command
cmd_new() {
    local database=""

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --database)
                database="$2"
                shift 2
                ;;
            --help|-h)
                usage_new
                exit 0
                ;;
            *)
                echo "Error: Unknown option $1" >&2
                usage_new
                exit 1
                ;;
        esac
    done

    # Validate database argument
    if [ -z "$database" ]; then
        echo "Error: --database is required" >&2
        usage_new
        exit 1
    fi

    # Check if database already exists
    database_dir="$RULES_DIR/$database"
    if [ -d "$database_dir" ]; then
        echo "Error: Database '$database' already exists at $database_dir" >&2
        exit 1
    fi

    # Create database structure
    echo "Creating new database: $database"
    mkdir -p "$database_dir/rules"

    # Create manifest template
    cat > "$database_dir/manifest" <<EOF
# Add your rule files below using the pipe format

| basic
# | advanced

# Include rules from other databases:
# | other-database/specific-rule
EOF

    # Create example rule file
    cat > "$database_dir/rules/basic.md" <<EOF
# Basic $database Rules

Add your rules here.

## Guidelines

Your content goes here.

\`\`\`bash
# Example code block
echo "Hello $database"
\`\`\`
EOF

    echo "✓ Created database structure at $database_dir"
    echo "✓ Created manifest: $database_dir/manifest"
    echo "✓ Created example rule: $database_dir/rules/basic.md"
    echo ""
    echo "Next steps:"
    echo "1. Edit $database_dir/manifest to include your rules"
    echo "2. Add rule files to $database_dir/rules/"
    echo "3. Build with: ai-rules build --manifest $database_dir/manifest"
}

# Validate command
cmd_validate() {
    local manifest=""

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --manifest)
                manifest="$2"
                shift 2
                ;;
            --help|-h)
                usage_validate
                exit 0
                ;;
            *)
                echo "Error: Unknown option $1" >&2
                usage_validate
                exit 1
                ;;
        esac
    done

    # Validate manifest argument
    if [ -z "$manifest" ]; then
        echo "Error: --manifest is required" >&2
        usage_validate
        exit 1
    fi

    # Check if manifest exists
    if [ ! -f "$manifest" ]; then
        echo "Error: Manifest file not found: $manifest" >&2
        exit 1
    fi

    manifest_dir=$(dirname "$manifest")
    database=$(basename "$manifest_dir")

    echo "Validating manifest: $manifest"
    echo "Database path: $manifest_dir"
    echo ""

    # Validation counters
    total_rules=0
    missing_rules=0
    valid_rules=0

    # Parse manifest and validate each rule
    local prev_level=0
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip empty lines
        if [ -z "$line" ]; then
            continue
        fi

        # Skip comments
        case "$line" in
            '#'*)
                continue
                ;;
            *)
                # Try to parse as pipe-based line
                if parsed=$(parse_pipe_line "$line"); then
                    # Extract level and rule name
                    level=$(echo "$parsed" | cut -d' ' -f1)
                    rule_name=$(echo "$parsed" | cut -d' ' -f2-)

                    # Validate nesting (can't jump levels) - show warning but auto-correct
                    if [ $level -gt $((prev_level + 1)) ]; then
                        corrected_level=$((prev_level + 1))
                        echo "⚠ Nesting warning: level $level follows level $prev_level (will auto-correct to $corrected_level)"
                        echo "   Line: $line"
                        level=$corrected_level
                    fi

                    total_rules=$((total_rules + 1))

                    # Add .md extension if not present
                    case "$rule_name" in
                        *.md)
                            # Already has extension
                            ;;
                        *)
                            # Add .md extension
                            rule_name="$rule_name.md"
                            ;;
                    esac

                    # Check if rule file exists
                    case "$rule_name" in
                        */*)
                            # Cross-database reference: database/rule -> RULES_DIR/database/rules/rule.md
                            db_name="${rule_name%%/*}"
                            rule_file="${rule_name#*/}"
                            # Remove .md if present, will be re-added
                            rule_file="${rule_file%.md}.md"
                            rule_path="$RULES_DIR/$db_name/rules/$rule_file"
                            ;;
                        *)
                            # Local rule
                            rule_path="$manifest_dir/rules/$rule_name"
                            ;;
                    esac

                    if [ -f "$rule_path" ]; then
                        echo "✓ $rule_name (level $level)"
                        valid_rules=$((valid_rules + 1))
                    else
                        echo "✗ $rule_name (not found: $rule_path)"
                        missing_rules=$((missing_rules + 1))
                    fi
                    prev_level=$level
                else
                    # Try legacy format (lines without pipes)
                    trimmed=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                    if [ -n "$trimmed" ]; then
                        total_rules=$((total_rules + 1))

                        # Check if rule file exists (legacy format)
                        case "$trimmed" in
                            */*)
                                # Cross-database reference
                                rule_path="$RULES_DIR/$trimmed"
                                ;;
                            *)
                                # Local rule
                                rule_path="$manifest_dir/rules/$trimmed"
                                ;;
                        esac

                        if [ -f "$rule_path" ]; then
                            echo "✓ $trimmed (legacy format)"
                            valid_rules=$((valid_rules + 1))
                        else
                            echo "✗ $trimmed (not found: $rule_path)"
                            missing_rules=$((missing_rules + 1))
                        fi
                    fi
                fi
                ;;
        esac
    done < "$manifest"

    echo ""
    echo "Validation Summary:"
    echo "Total rules: $total_rules"
    echo "Valid rules: $valid_rules"
    echo "Missing rules: $missing_rules"

    if [ $missing_rules -eq 0 ]; then
        echo ""
        echo "✓ Database '$database' is valid!"
        exit 0
    else
        echo ""
        echo "✗ Database '$database' has $missing_rules missing rule(s)"
        exit 1
    fi
}

# Main command dispatcher
case "${1:-}" in
    build)
        shift
        cmd_build "$@"
        ;;
    install)
        shift
        cmd_install "$@"
        ;;
    build-link)
        shift
        cmd_build_link "$@"
        ;;
    validate)
        shift
        cmd_validate "$@"
        ;;
    new)
        shift
        cmd_new "$@"
        ;;
    help|--help|-h)
        usage
        exit 0
        ;;
    "")
        usage
        exit 0
        ;;
    *)
        echo "Error: Unknown command '$1'" >&2
        echo ""
        usage
        exit 1
        ;;
esac
